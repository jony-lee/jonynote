# 设计模式

设计模式的核心是复用和解耦，使不稳定依赖于稳定，具体依赖于抽象。


## 设计模式的分类

- 创建型模式：将对象的创建与使用进行分离
- 结构型模式：描述如何将类对象接口之间按某种布局组成更大的结构
- 行为型模式：描述程序在运行时复杂的控制流程

## 分类

|序号|模式名称|适用场景|
|---|---|---|
|1 |单例模式 (Singleton)|无状态类使用单例模式可以节省内存资源|
|2 |工厂方法模式 (Factory Method)|在不知道具休实现细节的储况下创建对象的场景|
|3 |抽象工厂模式 (AbstractFactory)|容户游与对象创建解網，需要创建多个不同类型的对象的场景|
|4 |建造者模式 (Builder)|生成复杂对象的场景||
|5 |原型模式 (Prototype)|快速创建大量同类对象的场景|
|6 |适配器模式 (Adapter)|让两个不兼容的类一起工作的场景|
|7 |桥接模式 (Bridge)|将一个类的抽象部分和实现部分独立改变的场景|
|8 |组合模式 (Composite)|表示树形结构的场景|
|9 |装饰模式 (Decorator)|动态地为对象添加新职责的场景|
|10 |外观模式 (Facade)|为一个复杂的子系统提供一个简单的接口的场景|
|11 |享元模式 (Fly weight)|在多个地方共享大量细粒度对象的场景|
|12 |代理模式 (Proxy)|在访问某个对象时增加额外控制的场景|
|13 |模板方法模式 (TemplateMethod)|在不改交算法结构的悄況 下重定义算法中的某些步骤的场景|
|14 |策略模式 (Strategy)|在不同情況下使用不向算法的场景|
|15 |命令模式 (Command)|支特命令的撤销和恢复、延迟调用或日志操作的场景|
|16 |职责链模式 (Chain of Responsibility)|在不明确指定接收者的情况下，向多个对象中提交一个请求的场景|
|17 |状态模式(State)|根据对象的状态来改变它的行为的场景|
|18 |观察者棪式 (Observer)|在对象之间松散耦合的场景|
|19 |中介者模式 (Mediator)|在多个对象之间松散耦合的场最|
|20 |迭代器模式 (Iterator)|为容器对象提供多种遍历方式的场景|
|21 |访问者模式 (Visitor)|在不改变各元素的类的前提下定义对这些元素的新操作的场景|
|22 |备忘录模式 (Memento)|历史回放或者回滚等场景|
|23 |解释器模式 (Interpreter)|定义一个语言并为该语言实现一个解释器的场景|

